1. Define Software Engineering: What is software engineering
• Software engineering is the process of developing, testing, and deploying computer applications to solve real-world problems. 
How does it differ from traditional programming?
•	Process-oriented: Software engineering emphasizes a structured and organized process for developing software, rather than ad-hoc or unstructured approaches in Traditional Programming.
•	Software engineering often involves larger teams and collaboration across multiple disciplines while Traditional programming might be done by individual programmers or small teams without extensive planning or documentation.



2.	Software Development Life Cycle (SDLC): Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Software Development Life Cycle (SDLC): The Software Development Life Cycle (SDLC) is a structured process that outlines the various phases involved in developing software. The phases are:
	• Requirements Gathering: Understanding and documenting the needs and requirements of stakeholders and users.
	• Analysis: Analyzing the gathered requirements and defining the system's scope, constraints, and feasibility.
	• Design: Creating the software architecture, data structures, and user interfaces based on the requirements and analysis.
  • Implementation: Writing the actual code and developing the software based on the design specifications.
	• Testing: Verifying the software's functionality, performance, and quality through various testing techniques (e.g., unit testing, integration testing, system testing).
	• Deployment: Installing and releasing the software for end-users or customers.
	• Maintenance: Ongoing support, bug fixes, and enhancements to the software after deployment.



3.	Agile vs. Waterfall Models: Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Waterfall Model:
•	Approach: Sequential and linear.
•	Flexibility: Low, changes are difficult to incorporate once a phase is completed.
•	Phases: Distinct phases such as requirements, design, implementation, testing, and maintenance.
•	Collaboration: Less focus on collaboration; each phase is completed before the next begins.
•	Scenarios: Suitable for projects with well-defined, stable requirements and where a structured approach is needed.
•	
Agile Model:
•	Approach: Iterative and incremental.
•	Flexibility: High, allows for changes and feedback during development.
•	Phases: Continuous iteration of development and testing.
•	Collaboration: Strong emphasis on team collaboration and customer feedback.
•	Scenarios: Preferred for projects with evolving requirements, where rapid delivery and flexibility are crucial.
The Waterfall model is preferred for projects with well-defined and stable requirements, while the Agile model is better suited for projects with evolving requirements or rapidly changing environments.



4.	Requirements Engineering: What is requirements engineering?
• Requirements engineering is the process of defining, documenting, and maintaining the requirements for a software system. It involves gathering user needs, analyzing them, and specifying clear, actionable requirements for the development team.
Describe the process and its importance in the software development lifecycle.
•	Elicitation: Gathering requirements from stakeholders.
•	Analysis: Evaluating and prioritizing requirements.
•	Specification: Documenting the requirements in a clear and detailed manner.
•	Validation: Ensuring the requirements meet the stakeholders' needs and are feasible.
•	Management: Keeping track of requirements changes and ensuring consistency.
Importance: Ensures the final product meets user needs, reduces project risks, and provides



6.	Software Design Principles: Explain the concept of modularity in software design.
• Modularity is a design principle that emphasizes dividing software into independent, self-contained units (modules) with defined interfaces.
How does it improve maintainability and scalability of software systems?
Modularity improves maintainability and scalability of software systems in the following ways:
•	Maintainability: Individual modules can be easily modified or replaced without affecting the entire system.
•	Scalability: Functionality can be added by creating new modules without rewriting existing code.
•	Reusability: Modules can be reused in other projects, saving development time Software Design Principles: Building with Modularity



7.	Testing in Software Engineering. Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). 
•	Unit testing: Testing individual units or components of the software (e.g., functions, methods, classes) in isolation.
•	Integration testing: Testing how different units or components work together when integrated.
•	System testing: Testing the complete, integrated software system as a whole.
•	Acceptance testing: Testing the software against the specified requirements and user scenarios to ensure it meets the intended functionality and expectations.
Why is testing crucial in software development?
• Testing is essential because it helps identify and fix defects early in the development process, reduces the risk of failures and costly rework, and ultimately increases user satisfaction and confidence in the software.


8. Version Control Systems: What are version control systems, and why are they important in software development? 
Version control systems are software tools that track changes made to code over time. This allows developers to:
•	Revert to previous versions if problems arise.
•	Collaborate on code changes simultaneously.
•	Track who made what changes and when
Give examples of popular version control systems and their features.
1.	Git: A distributed VCS widely used for open-source and commercial projects, known for its branching and merging capabilities.
2.	Subversion (SVN): A centralized VCS that maintains a single repository on a server.
3.	Mercurial: A distributed VCS similar to Git, with a focus on simplicity and performance.



9.	Software Project Management: Discuss the role of a software project manager
• A software project manager is responsible for planning, organizing, and overseeing the development of software projects from inception to delivery.
What are some key responsibilities and challenges faced in managing software projects?
1.	Assembling and managing the project team, assigning tasks, and ensuring efficient utilization of resources.
2.	Facilitating effective communication between team members, stakeholders, and clients, and managing expectations.
3.	Ensuring adherence to quality standards, processes, and best practices throughout the project lifecycle.



10.	Software Maintenance: Define software maintenance and explain the different types of maintenance activities. 
• Software maintenance refers to the activities that are involved in modifying, enhancing, and supporting software systems after their initial release.
Different types of Maintenance activities;
•	Corrective maintenance: Fixing defects, bugs, or errors in the software.
•	Adaptive maintenance: Modifying the software to adapt to changes in the operating environment, hardware, or other external factors.
•	Perfective maintenance: Enhancing the software by adding new features, improving performance, or improving user experience.
•	Preventive maintenance: Proactive activities to prevent future issues, such as code refactoring, documentation updates, or performance optimization.
Why is maintenance an essential part of the software lifecycle?
This is essential because software systems require ongoing support, updates, and enhancements to meet the user’s needs and address security issues.



11.	Ethical Considerations in Software Engineering: What are some ethical issues that software engineers might face? 
• Respecting Intellectual property rights like patents and copyrights.
• Adhering to professional codes of conduct and maintaining transparency in their work.
• Avoiding biased or discriminatory algorithms, data, or design practices that could perpetuate societal inequalities or harm marginalized groups
• Considering the environmental impact of software systems, such as energy consumption and e-waste, and promoting sustainable practices.
• Designing software that is accessible and usable for all users, including those with disabilities or diverse backgrounds.
• Ensuring that software systems handle user data securely and ethically, respecting privacy rights and regulations.
How can software engineers ensure they adhere to ethical standards in their work?
•	Following professional codes of conduct
•	Implementing Best Practices in Software Development	
•	Transparency and Accountability with the software like its limitations.
•	Respect for User Privacy and Data Protection
•	Promoting Inclusivity and Fairness
